// Final Project
// report.txt
// Grace Milton and Roann Yanes
// May need to scroll down to see whole report

The program, from the user's perspective, is a standard game of Tetris. The left side of the screen is the Tetris board; the right side has a title and instructions for game play. Tetris pieces begin descending immediately when the game begins. There are seven different pieces. The user can move the pieces left and right across the board by pressing the left and right arrow keys, respectively. The user can rotate the pieces by pressing 'r', and quit the game by pressing 'q'. If the user fills a row, the row clears. If no more pieces can be added, then the game ends; a black screen with a congratulatory message ("GOOD JOB" in colorful block letters) appears to the user, and the window closes after a few seconds. 

     Internally, the program, from the programmer's perspective, begins by opening the graphics window, initializing the board with the initialize() method, and drawing the lines. Then, the program enters a while loop under the condition run equals true; it then draws a border between the left and right half of the screen, displays the word "TETRIS" using the title() function, and displays instructions. The blocks always start as orientation 1, and their shapes are randomly decided using rand(). Addblock() is used to start each piece at (5,0). A switch case then determines the bottom boundary based on each shape. The program then enters a for loop which runs until the piece reaches its bottom boundary. The checkbelow() method is used to determine if there is a piece below the current piece. If there is, the program runs the clearLine() method four times and checks to see if it is the end of the game using getEndgame(). If getEndgame() return true, then the screen clears, and the function goodjob() is used in a for loop with a usleep(). After the for loop ends, run is set to false. If getEndgame() returns false, the program breaks out of the for loop it is in. The fall() method is used to make the piece descend and usleep() is used to move it at a reasonable speed. If the piece is at its bottom boundary, clearLine() is called to determine if the line needs to be cleared. Then, openRotate() checks if the piece has room to rotate. A switch case is also used to account for pieces rotating off of the screen at the bottom. Gfx_event_waiting is called and placed in a switch case; if a button is pressed, gfx_wait is called and used to determine if the user is trying to move the piece left or right, rotate the piece, or quit. If any other event occurs, gfx_wait is used to make sure the commands don't queue up. The title() and goodjob() functions display "TETRIS" or "GOOD JOB" in the graphics window using polygons.

  In tetrisboard.cpp, there is a constructor, deconstructor, get methods that return the private attributes, and set methods that set the private attributes. Four of the private attributes are 2D arrays called currentboard, tempboard, colorboard, tempcolorboard. Currentboard        
keeps track of the pieces; colorboard keeps track of the colors of each block. Tempboard and tempcolorboard are each used to move the board down one row when a row is cleared. Initialize() sets the boards to ' ' (empty) or 0 (black). DrawLines() uses nested for loops to draw vertical and horizontal lines with gfx_line. Addblock() contains a switch case that sets the value of "endgame" to true if a piece intersects the location of the starting piece; another switch case is used to actually add the shape, and sets the currentboard equal to 'X' and colorboard equal to an integer that corresponds to the color of each piece. Addblock() actually draws the polygon for each shape in the graphics window. Removeblock() is the same as addblock() except it doesn't reference endgame; currentboard becomes a ' ', colorboard becomes zero, and it draws over the shape on the board in black. The fall() method works by adding and removing the piece from its current position and adding the piece to the next position (to make it appear as though it is falling); it also sets the new coordinates of the piece. MoveLeft() uses a switch case to determine if a piece can move left based on another piece or the edge of the board being next to it; it, then, works like fall() except it re-adds the piece one space over to the left instead of one space down and sets the coordinates one space over to the left instead of one space down. MoveRight() is the exact same as moveLeft except it checks to the right and moves to the right. OpenRotate() uses a switch case to check for the conditions of each piece; in each case, it determines if, when the piece is rotated, it will intersect with another piece or with the left or right of the board. If it will it returns false; if not, it returns true.  Rotate() removes the current piece and increments the current orientation by one unless the orientation is 4. Then, it resets it to 1. It re-adds the piece with the new orientation. Checkbelow() utilizes a switch case and series of if-statements (based on the shapes and the orientations of the pieces) to determine if there is a Tetris piece in the location of the board that the current piece is headed so that the current piece does not attempt to take that piece's location. If there is a piece in the location below, then checkbelow() returns true, and the current piece lands on top of that piece. If not, the current piece keeps falling until it hits the bottom of the board. 

   ClearLine() keeps a count of how many 'X' are in a row on currentboard. The count is cleared at the end of each row. If the entire row is filled, then the pieces are set in tempboard one row below where the are in currentboard. The same thing is done with the colors in colorboard and tempcolorboard. A switch case is used to color each block in with its new color. At the end, the values stored in tempboard and tempcolorboard are reassigned to currentboard and colorboard. 

   In order to evaluate the program for correctness, we ran the game several times and tested each feature of the program to see if everything was working properly. We made sure that the pieces do not rotate out of bounds (when the user presses 'r'), and that the pieces do not move too far to the left or too far to the right of the board when the user presses the arrow keys. We also made sure that the "quit" feature works as well. We tried to test different scenarios that could potentially prove problematic (like rotating over another piece, clearing multiple rows at once, clearing a row in the middle, pieces "eating" each other when moving side to side, etc.) to try and eliminate as many problems as possible. We were able to account for the problems listed above after frequent testing of the game; we have tried our best to account for all possible errors. 
